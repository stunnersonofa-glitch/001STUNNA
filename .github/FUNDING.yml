# These/**
 * webhook_server_sample.js
 * Production-ready Express webhook receiver for Travel Approval Workflow
 *
 * Features:
 * - API Key auth (header: x-api-key)
 * - SecurityHash verification (HMAC-SHA256 using SECRET_SIGNING_KEY)
 * - AppSheet API update helper
 * - M-Pesa (Daraja) OAuth + STK Push helper
 * - MPesa callback endpoint (stub/verify)
 * - Logging via winston
 * - Rate limiting
 *
 * Required environment variables (.env):
 * PORT=4000
 * WEBHOOK_API_KEY=replace_with_strong_random_key
 * SECRET_SIGNING_KEY=replace_with_signing_secret_for_hashes
 * APPSHEET_APP_ID=your_appsheet_app_id
 * APPSHEET_ACCESS_KEY=your_appsheet_application_access_key
 * MPESA_CONSUMER_KEY=...
 * MPESA_CONSUMER_SECRET=...
 * MPESA_ENV=sandbox | production
 * MPESA_SHORTCODE=...
 * MPESA_PASSKEY=... (for STK)
 * MPESA_CALLBACK_URL=https://webhook.yourdomain.com/mpesa/callback
 * ADMIN_EMAIL=stunnersonof@gmail.com
 *
 * Install dependencies:
 * npm i express body-parser helmet dotenv node-fetch crypto winston express-rate-limit
 *
 * Run:
 * node webhook_server_sample.js
 *
 * NOTE: This is a template. You MUST secure your server, rotate keys, use HTTPS via nginx/Certbot.
 */

require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const helmet = require('helmet');
const crypto = require('crypto');
const fetch = require('node-fetch'); // node >= 18 has fetch builtin; using node-fetch for compatibility
const winston = require('winston');
const rateLimit = require('express-rate-limit');

const {
  WEBHOOK_API_KEY,
  SECRET_SIGNING_KEY,
  APPSHEET_APP_ID,
  APPSHEET_ACCESS_KEY,
  MPESA_CONSUMER_KEY,
  MPESA_CONSUMER_SECRET,
  MPESA_ENV,
  MPESA_SHORTCODE,
  MPESA_PASSKEY,
  MPESA_CALLBACK_URL,
  PORT = 4000
} = process.env;

if (!WEBHOOK_API_KEY || !SECRET_SIGNING_KEY) {
  console.error('Missing required env vars: WEBHOOK_API_KEY or SECRET_SIGNING_KEY. Exiting.');
  process.exit(1);
}

/* -------------------------
   Simple logger (winston)
   -------------------------*/
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(info => `[${info.timestamp}] ${info.level.toUpperCase()}: ${info.message}`)
  ),
  transports: [new winston.transports.Console()]
});

/* -------------------------
   Express App + security
   -------------------------*/
const app = express();
app.use(helmet());
app.use(bodyParser.json({ limit: '1mb' }));

// Rate limiter - adjust as necessary
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 200
});
app.use(limiter);

/* -------------------------
   Middleware: API Key auth
   -------------------------*/
function apiKeyAuth(req, res, next) {
  const key = (req.headers['x-api-key'] || '').toString();
  if (!key || key !== WEBHOOK_API_KEY) {
    logger.warn(`Unauthorized request from ${req.ip}`);
    return res.status(401).json({ error: 'Unauthorized' });
  }
  return next();
}

/* -------------------------
   Utility: HMAC SHA256 verify
   - Expected: HMAC_SHA256(SECRET_SIGNING_KEY, canonicalPayload)
   - canonicalPayload: JSON string of payload fields in agreed order (see caller)
   -------------------------*/
function computeHmac(payloadString) {
  return crypto.createHmac('sha256', SECRET_SIGNING_KEY).update(payloadString, 'utf8').digest('hex');
}

/* -------------------------
   AppSheet API helper
   -------------------------*/
async function appsheetEditRow(tableName, rowObj) {
  if (!APPSHEET_APP_ID || !APPSHEET_ACCESS_KEY) {
    throw new Error('AppSheet credentials missing in env');
  }
  const url = `https://api.appsheet.com/api/v2/apps/${APPSHEET_APP_ID}/tables/${encodeURIComponent(tableName)}/Action`;
  const body = {
    Action: 'Edit',
    Properties: { Locale: 'en-US' },
    Rows: [rowObj]
  };
  const resp = await fetch(url, {
    method: 'POST',
    headers: {
      'ApplicationAccessKey': APPSHEET_ACCESS_KEY,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });
  const json = await resp.json();
  if (!resp.ok) {
    logger.error('AppSheet API error: ' + JSON.stringify(json));
    throw new Error('AppSheet API failed: ' + (json.error || JSON.stringify(json)));
  }
  return json;
}

/* -------------------------
   M-Pesa (Daraja) helpers
   - getMpesaToken()
   - lipaNaMpesaSTK()
   - handleMpesaCallback()
   -------------------------*/
const MPESA_BASE = (MPESA_ENV === 'production') ? 'https://api.safaricom.co.ke' : 'https://sandbox.safaricom.co.ke';

async function getMpesaToken() {
  if (!MPESA_CONSUMER_KEY || !MPESA_CONSUMER_SECRET) {
    throw new Error('M-Pesa credentials not set');
  }
  const url = `${MPESA_BASE}/oauth/v1/generate?grant_type=client_credentials`;
  const auth = Buffer.from(`${MPESA_CONSUMER_KEY}:${MPESA_CONSUMER_SECRET}`).toString('base64');
  const resp = await fetch(url, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${auth}`
    }
  });
  const data = await resp.json();
  if (!resp.ok) {
    logger.error('M-Pesa token error: ' + JSON.stringify(data));
    throw new Error('M-Pesa token error');
  }
  return data.access_token;
}

// Encoded password for STK: base64(shortcode + passkey + timestamp)
function buildStkPassword(shortcode, passkey, timestamp) {
  return Buffer.from(`${shortcode}${passkey}${timestamp}`).toString('base64');
}

async function lipaNaMpesaSTK(amount, phoneNumber, accountRef, callbackUrl) {
  const accessToken = await getMpesaToken();
  const url = `${MPESA_BASE}/mpesa/stkpush/v1/processrequest`;
  const timestamp = new Date().toISOString().replace(/[-:TZ.]/g, '').slice(0, 14);
  const password = buildStkPassword(MPESA_SHORTCODE, MPESA_PASSKEY, timestamp);
  const body = {
    BusinessShortCode: MPESA_SHORTCODE,
    Password: password,
    Timestamp: timestamp,
    TransactionType: 'CustomerPayBillOnline',
    Amount: amount,
    PartyA: phoneNumber,
    PartyB: MPESA_SHORTCODE,
    PhoneNumber: phoneNumber,
    CallBackURL: callbackUrl || MPESA_CALLBACK_URL,
    AccountReference: accountRef || 'Withdrawal',
    TransactionDesc: 'Withdrawal Payment'
  };
  const resp = await fetch(url, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });
  const data = await resp.json();
  if (!resp.ok) {
    logger.error('STK push error: ' + JSON.stringify(data));
    throw new Error('STK push failed');
  }
  return data;
}

/* -------------------------
   Endpoint: /webhook/withdrawal
   - expects JSON payload with RequestID, User, TotalCost, Status, SecurityHash, etc.
   - middleware: apiKeyAuth
   - verifies SecurityHash (HMAC)
   - processes request: e.g., validate, create job, call mpesa if instructed, update AppSheet
   -------------------------*/
app.post('/webhook/withdrawal', apiKeyAuth, async (req, res) => {
  try {
    const payload = req.body || {};
    // Basic validation
    const { RequestID, User, TotalCost, Status, SecurityHash, MPesaNumber, Action } = payload;
    if (!RequestID || !User || !TotalCost || !SecurityHash) {
      logger.warn('Bad payload: missing required fields');
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Canonical payload string - MUST match client-side generation
    // Use consistent ordering of fields — change as needed (communicate to AppSheet generator)
    const canonical = `${RequestID}|${User}|${TotalCost}|${Status || ''}`;
    const expected = computeHmac(canonical);

    if (expected !== SecurityHash) {
      logger.warn(`Invalid SecurityHash for ${RequestID} - expected ${expected}, got ${SecurityHash}`);
      return res.status(403).json({ error: 'Invalid SecurityHash' });
    }

    logger.info(`Webhook received valid payload for ${RequestID} (action: ${Action || 'none'})`);

    // Example: if action instructs to pay, trigger M-Pesa STK
    if (Action === 'PAY' && MPesaNumber) {
      logger.info(`Triggering STK push for ${RequestID} -> ${MPesaNumber} amount ${TotalCost}`);
      try {
        const stkResp = await lipaNaMpesaSTK(TotalCost, MPesaNumber, RequestID);
        // You may want to store stkResp.TransactionId or CheckoutRequestID in DB for correlation
        logger.info(`STK push response: ${JSON.stringify(stkResp)}`);

        // Optionally, update AppSheet record to note STK initiated
        await appsheetEditRow('Withdrawals', {
          ID: RequestID,
          Status: 'Payment Initiated',
          AuditNotes: `STK initiated: ${stkResp.CheckoutRequestID || stkResp.ResponseDescription || JSON.stringify(stkResp)}`
        });
        return res.json({ status: 'stk_initiated', detail: stkResp });
      } catch (err) {
        logger.error('Error during STK push: ' + err.message);
        await appsheetEditRow('Withdrawals', {
          ID: RequestID,
          AuditNotes: `STK error: ${err.message}`
        }).catch(e => logger.warn('AppSheet update failed: ' + e.message));
        return res.status(500).json({ error: 'STK push failed', detail: err.message });
      }
    }

    // If not a payment action — maybe it's a record creation or status sync
    if (Action === 'CREATE' || Action === 'UPDATE') {
      // Translate payload to AppSheet edit or add as needed.
      const row = {
        ID: RequestID,
        Status: Status || 'Pending',
        AuditNotes: `Webhook received from ${User} at ${new Date().toISOString()}`
      };
      await appsheetEditRow('Withdrawals', row);
      return res.json({ status: 'ok', message: 'AppSheet updated' });
    }

    // Default: just accept and log
    return res.json({ status: 'received' });
  } catch (err) {
    logger.error('Webhook error: ' + err.stack);
    return res.status(500).json({ error: 'server_error', detail: err.message });
  }
});

/* -------------------------
   Endpoint: /mpesa/callback
   - receives Safaricom callback after STK push or B2C
   - verify structure, log, update AppSheet accordingly
   -------------------------*/
app.post('/mpesa/callback', async (req, res) => {
  try {
    const body = req.body || {};
    logger.info('MPesa callback received: ' + JSON.stringify(body));

    // Example of handling typical STK callback:
    // body.Body.stkCallback.ResultCode, Body.stkCallback.CheckoutRequestID, etc.
    // Validate and map to RequestID (we suggested using AccountReference=RequestID)

    // Extract checkout request and result
    const stk = body?.Body?.stkCallback;
    if (stk) {
      const checkoutRequestID = stk.CheckoutRequestID;
      const resultCode = stk.ResultCode;
      // Search your storage for AccountReference mapping (if you saved it on STK response)
      // For this sample, we assume AccountReference == RequestID, which your MPesa provider must include in callback's metadata.
      // Parse metadata (if present)
      const callbackMetadata = stk?.CallbackMetadata;
      let requestId = null;
      if (callbackMetadata && callbackMetadata.Item) {
        // Try to find account reference in metadata items
        const acct = callbackMetadata.Item.find(i => i.Name === 'AccountReference' || i.Name === 'Account No' || i.Name === 'BillRefNumber');
        if (acct) requestId = acct.Value;
      }
      // Fallback: you might store mapping from CheckoutRequestID -> RequestID in DB earlier.
      // Update AppSheet accordingly
      const status = (resultCode === 0) ? 'Paid' : 'Payment Failed';
      const paidDate = new Date().toISOString();
      const rowUpdate = requestId ? { ID: requestId, Status: status, PaidDate: paidDate, AuditNotes: `M-Pesa callback: ${JSON.stringify(stk)}` } : null;

      if (rowUpdate) {
        try {
          await appsheetEditRow('Withdrawals', rowUpdate);
          logger.info('AppSheet updated after MPesa callback for ' + requestId);
        } catch (e) {
          logger.error('Failed to update AppSheet after MPesa callback: ' + e.message);
        }
      } else {
        logger.warn('Could not determine RequestID from MPesa callback. Save record for manual resolution.');
      }
      // respond 200 to Safaricom quickly
      return res.json({ ResultCode: 0, ResultDesc: 'Accepted' });
    }

    // If unknown format
    return res.status(400).json({ error: 'unknown mpesa callback format' });
  } catch (err) {
    logger.error('MPesa callback handler error: ' + err.stack);
    return res.status(500).json({ error: 'server_error' });
  }
});

/* -------------------------
   Health check & root
   -------------------------*/
app.get('/health', (req, res) => res.json({ status: 'ok', timestamp: new Date().toISOString() }));
app.get('/', (req, res) => res.send('Travel Approval Webhook Service'));

/* -------------------------
   Graceful shutdown
   -------------------------*/
const server = app.listen(PORT, () => {
  logger.info(`Webhook server listening on port ${PORT}`);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received: shutting down');
  server.close(() => process.exit(0));
});
process.on('SIGTERM', () => {
  logger.info('SIGTERM received: shutting down');
  server.close(() => process.exit(0));
});

/* -------------------------
   Unit test stubs (Jest) - save as webhook_server.test.js in __tests__ folder
   (Not run here; provided as helper)
   -------------------------*/

/*
Example Jest test file (not executed here):

// __tests__/webhook_server.test.js
const request = require('supertest');
const app = require('../webhook_server_sample'); // export app if you refactor

describe('Webhook endpoints', () => {
  test('health check', async () => {
    const res = await request(app).get('/health');
    expect(res.statusCode).toBe(200);
    expect(res.body.status).toBe('ok');
  });

  test('unauthorized webhook', async () => {
    const res = await request(app)
      .post('/webhook/withdrawal')
      .send({ RequestID: 'TST1', User: 'a@b.com', TotalCost: 100, Status: 'Submitted', SecurityHash: 'x' });
    expect(res.statusCode).toBe(401);
  });
});

To run tests:
npm i --save-dev jest supertest
Add to package.json: "test": "jest"
*/ are supported funding model platforms

github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
polar: # Replace with a single Polar username
buy_me_a_coffee: # Replace with a single Buy Me a Coffee username
thanks_dev: # Replace with a single thanks.dev username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
